/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. JSONParser.jj */
/*@egen*/options {
      STATIC = false;
      SUPPORT_CLASS_VISIBILITY_PUBLIC = true;
      ERROR_REPORTING = false;
      JAVA_UNICODE_ESCAPE = true;
      UNICODE_INPUT = true;
                               
                      
}

PARSER_BEGIN(JSONParser)
package org.timofeevAS.json;

//javase imports
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class JSONParser/*@bgen(jjtree)*/implements JSONParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTJSONParserState jjtree = new JJTJSONParserState();

/*@egen*/

    static protected String stripOffQuotes(String quotedString) {
        return quotedString.substring(1, quotedString.length() - 1);
    }
    public static String TRUE_ATOM = stripOffQuotes(tokenImage[K_TRUE]);
    public static String FALSE_ATOM = stripOffQuotes(tokenImage[K_FALSE]);

    public JSONParser() {
        super();
    }

    //cheat to sorta get generics on productions
    public <A> List<A> array() throws ParseException {
        return _array();
    }
    public <T> Map<String, T> object() throws ParseException {
        return _object();
    }
}

PARSER_END(JSONParser)

TOKEN_MGR_DECLS :
{
    static int commentNesting = 0;
}

// Pls see http://www.ietf.org/rfc/rfc4627.txt for JSON spec details

// white space
SKIP: {
        " "
    |   "\t"
    |   "\n"
    |   "\r"
    |   "\f"
}


// JSON reserved keywords (prefix with K_ to avoid naming conflicts): only lower case allowed!
TOKEN: {
        <K_TRUE: "true">
    |   <K_FALSE: "false">
    |   <K_NULL: "null">
}

// JSON operators (prefix with O_ to avoid naming conflicts)
TOKEN: {
        <O_OPENBRACE: "{">
    |   <O_CLOSEBRACE: "}">
    |   <O_OPENBRACKET: "[">
    |   <O_CLOSEBRACKET: "]">
    |   <O_COMMA: ",">
    |   <O_COLON: ":">
    |   <O_DOT: ".">
    |   <O_PLUS: "+">
    |   <O_MINUS: "-">
}

// numeric literals
TOKEN: {
        <#DIGIT: [
            //Unicode "DIGIT" characters - more inclusive than Character.isDigit
            "0"-"9" //DIGIT ZERO - DIGIT NINE
        ] >
    |   <#EXP: ["e", "E"] ( <O_PLUS > | <O_MINUS > )? >
}

// JSON numbers do not support octal or hexadecimal formats
TOKEN: {
        <NUMBER:  <INTEGER> | <INTEGER> <FRACTIONAL_DIGITS> | <INTEGER> <EXPONENT> | <INTEGER> <FRACTIONAL_DIGITS> <EXPONENT> >
    |   <INTEGER: (<O_MINUS>)? ( <DIGITS> ) > //support leading zeros
    |   <FRACTIONAL_DIGITS: <O_DOT> <DIGITS> >
    |   <EXPONENT: <EXP> <DIGITS> >
    |   <DIGITS: ( <DIGIT> )+ >
}

// string literals
TOKEN: {
        <QUOTED_STRING: "\"" ( (~["\"","\\"]) | ("\\" ( ["n","t","b","r","f","\\","\""] ) ) )* "\"">
    |   <SINGLE_QUOTED_STRING: "\'" ( (~["\'","\\"]) | ("\\" ( ["n","t","b","r","f","\\","\'"] ) ) )* "\'">
}
TOKEN: {
        <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT> | "_")* >
    |   <#LETTER: [
            //Unicode "LETTER" characters - as of Javase 6, Unicode 4 is supported
            //http://www.unicode.org/Public/4.1.0/ucd/NamesList.txt
            //more inclusive than Character.isLetter
           "$",          //DOLLAR SIGN
           "_"          //LOW LINE: spacing underscore
      ]
  >
}

Object parse():
{/*@bgen(jjtree) parse */
SimpleNode jjtn000 = new SimpleNode(JJTPARSE);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
/*@egen*/
Object o = null;
}
{/*@bgen(jjtree) parse */
    try {
/*@egen*/
    ( o=_object() | o=_array() )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        return o;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

protected Map _object():
{/*@bgen(jjtree) _object */
SimpleNode jjtn000 = new SimpleNode(JJT_OBJECT);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
/*@egen*/
Map m = new LinkedHashMap();
}
{/*@bgen(jjtree) _object */
    try {
/*@egen*/
    <O_OPENBRACE> ( members(m) )? <O_CLOSEBRACE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        return m;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

protected void members(Map m):
{/*@bgen(jjtree) members */
  SimpleNode jjtn000 = new SimpleNode(JJTMEMBERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) members */
    try {
/*@egen*/
    pair(m) [ <O_COMMA> members(m) ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

protected void pair(Map m):
{/*@bgen(jjtree) pair */
SimpleNode jjtn000 = new SimpleNode(JJTPAIR);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
/*@egen*/
Token t = null;
Object o;
String fieldName = null;
}
{/*@bgen(jjtree) pair */
    try {
/*@egen*/
    fieldName=fieldName() <O_COLON> o=value()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        m.put(fieldName, o);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

protected String fieldName():
{/*@bgen(jjtree) fieldName */
SimpleNode jjtn000 = new SimpleNode(JJTFIELDNAME);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
/*@egen*/
String fieldName = null;
}
{/*@bgen(jjtree) fieldName */
    try {
/*@egen*/
    (
      <SINGLE_QUOTED_STRING>
        {
          fieldName = stripOffQuotes(token.image);
        }
      |
      <QUOTED_STRING>
        {
          fieldName = stripOffQuotes(token.image);
        }
      |
      //some JSON systems now accept 'naked' JSON Objects
      <IDENTIFIER>
        {
          fieldName = token.image;
        }
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      return fieldName;
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

protected List _array():
{/*@bgen(jjtree) _array */
SimpleNode jjtn000 = new SimpleNode(JJT_ARRAY);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
/*@egen*/
List a=new ArrayList();
}
{/*@bgen(jjtree) _array */
    try {
/*@egen*/
    <O_OPENBRACKET> ( elements(a) )? <O_CLOSEBRACKET>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        Collections.reverse(a);
        return a;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

protected void elements(List a):
{/*@bgen(jjtree) elements */
SimpleNode jjtn000 = new SimpleNode(JJTELEMENTS);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
/*@egen*/
Object o = null;
}
{/*@bgen(jjtree) elements */
    try {
/*@egen*/
    o=value() [ <O_COMMA> elements(a) ]/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        a.add(o);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

protected Object value():
{/*@bgen(jjtree) value */
SimpleNode jjtn000 = new SimpleNode(JJTVALUE);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
/*@egen*/
Token t = null;
Object o = null;
}
{/*@bgen(jjtree) value */
    try {
/*@egen*/
    (   o=_object()
    |   o=_array()
    |   t=<IDENTIFIER> {o = t.image;} //'naked' values, too
    |   t=<SINGLE_QUOTED_STRING> {o = stripOffQuotes(t.image);}
    |   t=<QUOTED_STRING> {o = stripOffQuotes(t.image);}
    |   t=<NUMBER>
        {
            try {
              o = Integer.valueOf(t.image);
            }
            catch (NumberFormatException nfe1) {
                try {
                     o = new BigInteger(t.image);
                }
                catch  (NumberFormatException nfe2) {
                    try {
                         o = new BigDecimal(t.image);
                    }
                    catch  (NumberFormatException nfe3) {
                         o = Double.NaN;
                    }
                }
            }
        }
    |   <K_TRUE> {o = Boolean.TRUE;}
    |   <K_FALSE> {o = Boolean.FALSE;}
    |   <K_NULL> )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        return o;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
